# -*- coding: utf-8 -*-# Supplementary material for Ezaki et al. arXiv:2001.08369..# by Takahiro Ezaki. May 21, 2020.# This module contains functions to estimate GMM and HMM from an N-dimensional time course.import numpy as npfrom hmmlearn import hmmfrom sklearn import mixtureimport synthetic_time_seriesdef get_accuracy(true_state_time_series, predicted_state_time_series):    # This function computes the accuracy of a predicted time series of the state.    # Because the state label assigned to each hidden state is arbitrary in an estimated GMM/HMM,    # this function calculates the most likely assignment of the state label to each state.    trial_max = 10    t_max = len(true_state_time_series)    state_list = set(predicted_state_time_series)    state_number = len(state_list)    state_order = list(set(predicted_state_time_series))    # initial state    accurate_number = 0    for i in range(t_max):        if true_state_time_series[i] == predicted_state_time_series[i]:            accurate_number += 1    accuracy_rate = accurate_number / t_max    accuracy_max = accuracy_rate    for trial in range(trial_max):        reassigned = False  #flag for relabeling        for i in range(state_number):            for j in range(i + 1, state_number):                predicted_replaced = predicted_state_time_series                for jj in range(t_max):                    if predicted_replaced[jj] == i:                        predicted_replaced[jj] = j                    elif predicted_replaced[jj] == j:                        predicted_replaced[jj] = i                accurate_number = 0                for kkk in range(t_max):                    if true_state_time_series[kkk] == predicted_replaced[kkk]:                        accurate_number += 1                accuracy_rate = accurate_number / t_max                if accuracy_rate > accuracy_max:                    reassigned = True                    accuracy_max = accuracy_rate                    predicted_state_time_series = predicted_replaced                    for state in range(state_number):                        if state_order[state] == i:                            state_order[state] = j                        elif state_order[state] == j:                            state_order[state] = i        if not reassigned:            break    return accuracy_max, state_orderdef estimate_gmm(time_series, iter_number=10, component_number=2):    bic = + 100000000000    for i in range(iter_number):        model_gmm = mixture.GaussianMixture(n_components=component_number, covariance_type='full')        model_gmm.fit(time_series)        bic_temp = model_gmm.bic(time_series)        if bic > bic_temp:            bic = bic_temp            bestmodel = model_gmm    return bestmodeldef estimate_hmm(time_series, iter_number=10, component_number=2):    score = -100000000000    for i in range(iter_number):        model_hmm = hmm.GaussianHMM(n_components=component_number, covariance_type="full")        model_hmm.fit(time_series)        score_temp = model_hmm.score(time_series)        if score < score_temp:            score = score_temp            bestmodel = model_hmm    return bestmodelif __name__=='__main__':    #sample code    t_max = 10000    alpha = 1    #generate sample time series    sample_time_series, true_state_time_series = synthetic_time_series.markov_time_series(t_max,alpha)    #estimate models    estimated_gmm = estimate_gmm(sample_time_series)    estimated_hmm = estimate_hmm(sample_time_series)    #estimate hidden states    predicted_state_time_series_gmm = estimated_gmm.predict(sample_time_series)    predicted_state_time_series_hmm = estimated_hmm.predict(sample_time_series)    print("estimation by GMM: accuracy = ", get_accuracy(true_state_time_series,predicted_state_time_series_gmm)[0],          "\nestimation by HMM: accuracy = ", get_accuracy(true_state_time_series,predicted_state_time_series_hmm)[0])