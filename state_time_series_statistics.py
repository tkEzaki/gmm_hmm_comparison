# -*- coding: utf-8 -*-# Supplementary material for Ezaki et.al. arXiv:2001.08369..# by Takahiro Ezaki. May 21, 2020.# This module contains functions to compute statistics from a time course of the state.import numpy as npimport synthetic_time_seriesdef compute_state_frequency(state_time_series):    # input: state_time_series (1-dimensional time course of the state)    # outout: frequency (frequency[i] contains the frequency of the i-th hidden state)    state_num = int(state_time_series.max()) + 1    frequency = np.zeros(state_num)    t_max = len(state_time_series)    for t in range(t_max):        frequency[int(state_time_series[t])] += 1/t_max    return frequencydef compute_switching_rate(state_time_series):    # input: state_time_series (1-dimensional time course of the state)    # outout: switching_rate (switching_rate[i][j] contains switching rate from    #                         i-th hidden state to j-th hidden state)    state_num = int(state_time_series.max()) + 1    switching_rate = np.zeros((state_num, state_num))    t_max = len(state_time_series)    for t in range(t_max-1):        switching_rate[int(state_time_series[t])][int(state_time_series[t+1])] += 1/(t_max-1)    return switching_ratedef compute_dwell_time_distribution(state_time_series):    # input: state_time_series (1-dimensional time course of the state)    # outout: dwell_time_distribution    #        (dwell_time_distribution[i][t] contains the probability of    #         hidden state i having a dwell time of t time steps.)    state_num = int(state_time_series.max()) + 1    t_max = len(state_time_series)    dwell_time_distribution = np.zeros((state_num, t_max))    current_state = state_time_series[0]    dwell_time = 0    for t in range(t_max-1):        if current_state == state_time_series[t+1]:            dwell_time += 1        else:            dwell_time_distribution[int(current_state)][dwell_time] += 1            dwell_time = 1            current_state = state_time_series[t+1]    for state in range(state_num):        dwell_time_distribution[state,:] /= dwell_time_distribution[state,:].sum()    return dwell_time_distributionif __name__ == '__main__':    #sample code    sample_time_series, sample_state_time_series = synthetic_time_series.bernoulli_time_series(1000,1)    print(compute_state_frequency(sample_state_time_series))    print(compute_switching_rate(sample_state_time_series))    print(compute_dwell_time_distribution(sample_state_time_series)[:,0:20])