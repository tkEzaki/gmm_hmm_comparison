# -*- coding: utf-8 -*-# Supplementary material for Ezaki et.al. arXiv:2001.08369..# by Takahiro Ezaki. May 21, 2020.# This module contains functions to generate synthetic time series.import numpy as npdef load_cov_mean(alpha):    mean_mat = np.loadtxt('sample_mean_1_2.txt', delimiter='\t')    mean_mat = mean_mat * alpha    cov1 = np.loadtxt('sample_cov_1.txt', delimiter='\t')    cov2 = np.loadtxt('sample_cov_2.txt', delimiter='\t')    cov_mat = [cov1, cov2]    return mean_mat, cov_matdef deterministic_time_series(tmax, alpha):    #define mean and cov for each hidden state    mean_mat, cov_mat = load_cov_mean(alpha)    region_number = len(cov_mat[0])    state = 0    state_time_series = np.zeros(tmax)    time_series = np.zeros([tmax, region_number])    for i in range(tmax):        state_time_series[i] = state        time_series[i] = np.random.multivariate_normal(mean_mat[state], cov_mat[state])        if i % 2 == 0:            state = 1 - state    return time_series, state_time_seriesdef markov_time_series(tmax, alpha):    #define mean and cov for each hidden state    mean_mat, cov_mat = load_cov_mean(alpha)    region_number = len(cov_mat[0])    initial_state_prob = [0.5, 0.5]    initial_state = np.random.choice(2, p=initial_state_prob)    time_series = np.zeros([tmax, region_number])    state = initial_state    state_time_series = np.zeros(tmax)    transition_rates = np.loadtxt('trans.txt', delimiter='\t')    for i in range(tmax):        state_time_series[i] = state        time_series[i] = np.random.multivariate_normal(mean_mat[state], cov_mat[state])        state = np.random.choice(2, p=transition_rates[state])    return time_series, state_time_seriesdef bernoulli_time_series(tmax, alpha):    #define mean and cov for each hidden state    mean_mat, cov_mat = load_cov_mean(alpha)    region_number = len(cov_mat[0])    initial_state_prob = [0.5, 0.5]    initial_state = np.random.choice(2, p=initial_state_prob)    time_series = np.zeros([tmax, region_number])    state = initial_state    state_time_series = np.zeros(tmax)    for i in range(tmax):        state_time_series[i] = state        time_series[i] = np.random.multivariate_normal(mean_mat[state], cov_mat[state])        state = np.random.choice(2, p=initial_state_prob)    return time_series, state_time_seriesif __name__ == '__main__':    #sample code    tmax = 10000    alpha = 1.0    #generate deterministic time series    synthetic_time_series, true_state_time_series = deterministic_time_series(tmax,alpha)    # generate Markovian time series    synthetic_time_series, true_state_time_series = markov_time_series(tmax,alpha)    # generate Bernoulli time series    synthetic_time_series, true_state_time_series = bernoulli_time_series(tmax,alpha)